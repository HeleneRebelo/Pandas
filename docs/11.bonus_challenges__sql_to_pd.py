# -*- coding: utf-8 -*-
"""CÃ³pia de 11-bonus-challenges__sql-to-pd.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HcIrvwCBChnZXYEsJHD825eNYmfCmUWx

# From SQL to pandas challenge 11
"""

# import libraries
import pandas as pd

# load data
# This code is made to load our data stored on Google Drive
def gd_path(file_id):
    """Generate a shareable link from Google Drive file id."""
    return f"https://drive.google.com/uc?export=download&id={file_id}"

# Google Drive file ids
files_id = {
    "titleauthor": "1F1JOiYXStWacOBca6coNVfyVtoST7ZgD",
    "titles": "1PLdn50N9GRa53ZbuVWo0l47F_IXdvlEm",
    "sales": "1fzFc9rwYmVIPaGOFmhLVxCi3kg19vNU2",
    "roysched": "1zPRZPoFPEMKyrNR5VSENeYFHGCBZmxbs",
    "publishers": "1s9E8_AVOziTrowb3wyh2jg3PV763VOyq",
    "employee": "1h9mUjsVqpP74b1w0x7KOw37n_n9Ulkt5",
    "authors": "1fEF89Nhe61EebAljKlwFwfEuokK0o6aJ"
}

# Read data from Google Drive
sales = pd.read_csv(gd_path(files_id["sales"]), sep=";")
titles = pd.read_csv(gd_path(files_id["titles"]), sep=";")
publishers = pd.read_csv(gd_path(files_id["publishers"]), sep=";")
employee = pd.read_csv(gd_path(files_id["employee"]), sep=";")
authors = pd.read_csv(gd_path(files_id["authors"]), sep=";")
titleauthor = pd.read_csv(gd_path(files_id["titleauthor"]), sep=";")
roysched = pd.read_csv(gd_path(files_id["roysched"]), sep=";")

"""## 1. Using LEFT JOIN: in which city is the publisher of "Is Anger the Enemy" based?"""

(
    titles[titles.title == 'Is Anger the Enemy?']
    .join(publishers.set_index('pub_id'), on='pub_id')
    .city
)

"""### Hint:

In SQL the syntax is:

```sql
SELECT p.city
FROM publishers AS p
LEFT JOIN titles AS t
ON p.pub_id = t.pub_id
WHERE t.title = 'Is Anger the Enemy?';
```

## 2. Select all the book titles that have a link to the employee Howard Snyder
    (he works for the publisher that has published those books).
"""

(
    employee[(employee.fname == 'Howard') & (employee.lname == 'Snyder')]
    .join(titles.set_index('pub_id'), on='pub_id')
    ['title']
)

"""### Hint:

In SQL the syntax is:

```sql
SELECT t.title
FROM employee e
JOIN titles t
ON e.pub_id = t.pub_id
WHERE e.fname = 'Howard'
AND e.lname = 'Snyder';
```

## 3. Using the `merge` of your choice: Select the book title with highest number of sales (qty)
"""

(
    sales
    .groupby('title_id')
    .agg(sales=('qty', 'sum'))
    .join(titles.set_index('title_id'), on='title_id')
    .sort_values('sales', ascending=False)
    [['title', 'sales']]
    .head(1)
)

"""### Hint:

In SQL the syntax is:

```sql
SELECT t.title, SUM(qty)
FROM sales AS s
JOIN titles t
ON s.title_id = t.title_id
GROUP BY t.title_id
ORDER BY SUM(qty) desc
LIMIT 1;
```

# 4. Select all book titles and the full name of their author(s).
      
      - If a book has multiple authors, all authors must be displayed (in
      multiple rows).
      
      - Books with no authors and authors with no books should not be displayed.
"""

(
    titles
    .join(titleauthor.set_index('title_id'), on='title_id')
    .join(authors.set_index('au_id'), on='au_id', how='inner')
    .sort_values(['title', 'au_ord'])
    [['title', 'au_fname', 'au_lname']]
)

"""### Hint:

In SQL the syntax is:

```sql
SELECT
    t.title,
    a.au_fname,
    a.au_lname
FROM titles t
INNER JOIN titleauthor ta
ON t.title_id = ta.title_id
INNER JOIN authors a
ON ta.au_id = a.au_id;
```

## 5. Select the full name of authors of Psychology books

   Bonus hint: if you want to prevent duplicates but allow authors with shared
   last names to be displayed, you can concatenate the first and last names
   with CONCAT(), and use the DISTINCT clause on the concatenated names.
"""

(
    authors
    .join(titleauthor.set_index('au_id'), on='au_id', how='inner')
    .join(titles.set_index('title_id'), on='title_id', how='inner')
    .loc[lambda result: result.type == 'psychology', ['au_fname', 'au_lname']]
    .groupby(['au_fname', 'au_lname']).groups.keys()
)

# OR
(
    authors
    .join(titleauthor.set_index('au_id'), on='au_id', how='inner')
    .join(titles.set_index('title_id'), on='title_id', how='inner')
    .loc[lambda result: result.type == 'psychology']
    .assign(
        full_name = lambda result: result.au_fname + ' ' + result.au_lname
    )
    .full_name.unique()
)

# OR
(
    authors[authors.au_id.isin(
        titles[titles.type == 'psychology']
        .join(titleauthor.set_index('title_id'), on='title_id', how='inner')
        .au_id.unique())]
    [['au_fname', 'au_lname']]
)

"""### Hint:

In SQL the syntax is:

```sql
SELECT DISTINCT CONCAT(a.au_fname, " ", a.au_lname) AS full_name
FROM authors a
INNER JOIN titleauthor ta ON a.au_id = ta.au_id
INNER JOIN titles t ON ta.title_id = t.title_id
WHERE t.type = "psychology";
```

## 6. Explore the table roysched and try to grasp the meaning of each column.
   The notes below will help:
   
   - "Royalty" means the percentage of the sale price paid to the author(s).
   
   - Sometimes, the royalty may be smaller for the first few sales (which have
     to cover the publishing costs to the publisher) but higher for the sales
     above a certain threshold.
     
   - In the "roysched" table each title_id can appear multiple times, with
     different royalty values for each range of sales.
     
   - Select all rows for particular title_id, for example "BU1111", and explore
	 the data.
"""

roysched[roysched.title_id == 'BU1111']

"""### Hint:

In SQL the syntax is:

```sql
SELECT * FROM roysched WHERE title_id = "BU1111";
```

## 7. Select all the book titles and the maximum royalty they can reach.
    Display only titles that are present in the roysched table.
"""

roysched.info()

(
    titles[['title_id', 'title']]
    .join(roysched.set_index('title_id'), on='title_id', how='inner')
    .groupby('title_id')
    .agg(title = ('title', 'first'), max_royalty = ('royalty', 'max'))
    .sort_values('max_royalty', ascending=False)
)

"""### Hint:

In SQL the syntax is:

```sql
SELECT t.title, MAX(r.royalty) max_royalty
FROM titles t
INNER JOIN roysched r
ON t.title_id = r.title_id
GROUP BY t.title
ORDER BY max_royalty DESC;
```
"""